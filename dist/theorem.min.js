class TheoremJS{average(a){const b=this.sum(a),c=this.math.div(b,a.length);return c}get math(){const a={add(){return b.addSubDiv(arguments,0)},sub(){return b.addSubDiv(arguments,1)},mul(){return b.mul(arguments)},div(){return b.addSubDiv(arguments,3)}};var b={addSubDiv(a,b){const c=this.countDecimals(this.validMe(a)),d=this.biggestComma(c),e=3===b?0:d,f=this.shiftComma(this.countResult(this.toExponent(c,d),b),e);return this.isSafeInteger(f),f},mul(a){const b=this.countDecimals(this.validMe(a)),c=[];let d=0;for(const e in b)d+=b[e].comma,c.push(b[e].integer);return this.shiftComma(this.countResult(c,2),d)},isSafeInteger(a){if(a<=-9007199254740991||a>=9007199254740991)throw"DisplayJS: The result is not a safe integer."},shiftComma(a,b){return this.toExponent(this.countDecimals([a]),-b)[0]},countResult(a,b){let c=a[0];for(let d=1;d<a.length;d++)0===b?c+=a[d]:1===b?c-=a[d]:2===b?c*=a[d]:3===b?c/=a[d]:void 0;return c},toExponent(a,b){const c=[];for(const d in a){a[d].comma-=b;const e=0<=a[d].comma?"+":"";c.push(+`${a[d].integer.toString()}e${e}${a[d].comma}`)}return c},biggestComma(a){const b=[];for(const c in a)b.push(a[c].comma);return Math.min.apply(null,b)},validMe(a){if(2>a.length)throw"DisplayJS: Set at least two numerical values.";for(const b in a){if(a[b]=parseFloat(a[b]),"number"!=typeof a[b]||isNaN(a[b]))throw"DisplayJS: Every Math argument must be of type number.";if(a[b]===Number.POSITIVE_INFINITY||a[b]===Number.NEGATIVE_INFINITY)throw"DisplayJS: Every Math argument must be a numerical value between positive and negative Infinity."}return a},countDecimals(a){const b=[];for(const c in a){let d=0;const e=a[c].toString().split("e"),f=e[0].indexOf(".");d-=-1===f?0:e[0].length-1-f,d+=isNaN(+e[1])?0:+e[1],e[0]=+e[0].replace(".",""),b.push({integer:e[0],comma:d})}return b}};return a}median(a){a.sort((c,a)=>this.math.sub(c,a));const b=Math.floor(this.math.div(a.length,2));return a.length%2?a[b]:this.math.div(this.math.add(a[b-1],a[b]),2)}multiply(a){return a.reduce((c,a)=>this.math.mul(c,a))}predict(a,b,c=!1){const d=this.math,e=this,f=Object.keys(a);for(var g=0;g<f.length;g++)f[g]=parseFloat(f[g]);const h=Object.values(a),i=f.length;let j=[],k=[];for(let e of this.range(f.length-1))k.push(d.mul(f[e],f[e])),j.push(d.mul(f[e],h[e]));const l=e.sum(f),m=e.sum(h),n=e.sum(j),o=e.sum(k),p=d.div(d.sub(d.mul(i,n),d.mul(l,m)),d.sub(d.mul(i,o),d.mul(l,l))),q=d.div(d.sub(m,d.mul(p,l)),i);return!0==c?`f(x) = ${p}x+${q}; f(${b}) = ${b*p+q}`:b*p+q}sum(a){return a.reduce((c,a)=>this.math.add(c,a))}}"function"==typeof define&&define.amd?define(()=>new Glottologist):"undefined"==typeof exports?"undefined"!=typeof global&&(global.Glottologist=new Glottologist):("undefined"!=typeof module&&module.exports&&(exports=module.exports=new Glottologist),exports.Glottologist=new Glottologist);